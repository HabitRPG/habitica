// Generated by CoffeeScript 1.6.3
(function() {
  var algos, helpers, misc, moment, _;

  algos = require('habitrpg-shared/script/algos');

  helpers = require('habitrpg-shared/script/helpers');

  _ = require('lodash');

  moment = require('moment');

  misc = require('./misc');

  /*
    Make scoring functionality available to the app
  */


  module.exports.app = function(appExports, model) {
    var user;
    user = model.at('_user');
    appExports.addTask = function(e, el) {
      var newModel, newTask, text, type;
      type = $(el).attr('data-task-type');
      newModel = model.at('_new' + type.charAt(0).toUpperCase() + type.slice(1));
      text = newModel.get();
      if (/^(\s)*$/.test(text) || text === void 0) {
        return;
      }
      newTask = {
        id: model.id(),
        type: type,
        text: text,
        notes: '',
        value: 0
      };
      newTask.tags = _.reduce(user.get('filters'), (function(memo, v, k) {
        if (v) {
          memo[k] = v;
        }
        return memo;
      }), {});
      switch (type) {
        case 'habit':
          newTask = _.defaults({
            up: true,
            down: true
          }, newTask);
          break;
        case 'reward':
          newTask = _.defaults({
            value: 20
          }, newTask);
          break;
        case 'daily':
          newTask = _.defaults({
            repeat: {
              su: true,
              m: true,
              t: true,
              w: true,
              th: true,
              f: true,
              s: true
            },
            completed: false
          }, newTask);
          break;
        case 'todo':
          newTask = _.defaults({
            completed: false
          }, newTask);
      }
      e.at().unshift(newTask);
      return newModel.set('');
    };
    appExports.del = function(e) {
      if (confirm("Are you sure you want to delete this task?") !== true) {
        return;
      }
      $('[rel=tooltip]').tooltip('hide');
      user.del("tasks." + (e.get('id')));
      return e.at().remove();
    };
    appExports.clearCompleted = function(e, el) {
      var completedIds, todoIds;
      completedIds = _.pluck(_.where(model.get('_todoList'), {
        completed: true
      }), 'id');
      todoIds = user.get('todoIds');
      _.each(completedIds, function(id) {
        user.del("tasks." + id);
        return true;
      });
      return user.set('todoIds', _.difference(todoIds, completedIds));
    };
    appExports.toggleDay = function(e, el) {
      var task;
      task = model.at(e.target);
      if (/active/.test($(el).attr('class'))) {
        return task.set('repeat.' + $(el).attr('data-day'), false);
      } else {
        return task.set('repeat.' + $(el).attr('data-day'), true);
      }
    };
    appExports.toggleTaskEdit = function(e, el) {
      var chartPath, editPath, id, _ref;
      id = e.get('id');
      _ref = ["_tasks.editing." + id, "_page.charts." + id], editPath = _ref[0], chartPath = _ref[1];
      model.set(editPath, !(model.get(editPath)));
      return model.set(chartPath, false);
    };
    appExports.toggleChart = function(e, el) {
      var chart, data, history, historyPath, id, matrix, options, togglePath, _ref, _ref1, _ref2, _ref3;
      id = $(el).attr('data-id');
      _ref = ['', ''], historyPath = _ref[0], togglePath = _ref[1];
      switch (id) {
        case 'exp':
          _ref1 = ['_page.charts.exp', '_user.history.exp'], togglePath = _ref1[0], historyPath = _ref1[1];
          break;
        case 'todos':
          _ref2 = ['_page.charts.todos', '_user.history.todos'], togglePath = _ref2[0], historyPath = _ref2[1];
          break;
        default:
          _ref3 = ["_page.charts." + id, "_user.tasks." + id + ".history"], togglePath = _ref3[0], historyPath = _ref3[1];
          model.set("_tasks.editing." + id, false);
      }
      history = model.get(historyPath);
      model.set(togglePath, !(model.get(togglePath)));
      matrix = [['Date', 'Score']];
      _.each(history, function(obj) {
        return matrix.push([moment(obj.date).format('MM/DD/YY'), obj.value]);
      });
      data = google.visualization.arrayToDataTable(matrix);
      options = {
        title: 'History',
        backgroundColor: {
          fill: 'transparent'
        }
      };
      chart = new google.visualization.LineChart($("." + id + "-chart")[0]);
      return chart.draw(data, options);
    };
    appExports.todosShowRemaining = function() {
      return model.set('_showCompleted', false);
    };
    appExports.todosShowCompleted = function() {
      return model.set('_showCompleted', true);
    };
    /*
      Call scoring functions for habits & rewards (todos & dailies handled below)
    */

    appExports.score = function(e, el) {
      var direction, id;
      id = $(el).parents('li').attr('data-id');
      direction = $(el).attr('data-direction');
      return misc.score(model, id, direction, true);
    };
    /*
      This is how we handle appExports.score for todos & dailies. Due to Derby's special handling of `checked={:task.completd}`,
      the above function doesn't work so we need a listener here
    */

    user.on('set', 'tasks.*.completed', function(i, completed, previous, isLocal, passed) {
      var direction;
      if (!isLocal || (passed != null ? passed.cron : void 0)) {
        return;
      }
      direction = completed ? 'up' : 'down';
      return misc.score(model, i, direction, true);
    });
    /*
      Undo
    */

    appExports.undo = function() {
      var taskPath, undo;
      undo = model.get('_undo');
      if (undo != null ? undo.timeoutId : void 0) {
        clearTimeout(undo.timeoutId);
      }
      model.del('_undo');
      _.each(undo.stats, function(val, key) {
        user.set("stats." + key, val);
        return true;
      });
      taskPath = "tasks." + undo.task.id;
      return _.each(undo.task, function(val, key) {
        if (key === 'id' || key === 'type') {
          return true;
        }
        if (key === 'completed') {
          user.pass({
            cron: true
          }).set("" + taskPath + ".completed", val);
        } else {
          user.set("" + taskPath + "." + key, val);
        }
        return true;
      });
    };
    appExports.tasksToggleAdvanced = function(e, el) {
      return $(el).next('.advanced-option').toggleClass('visuallyhidden');
    };
    appExports.tasksSaveAndClose = function() {
      $('[rel=tooltip]').tooltip();
      return $('[rel=popover]').popover();
    };
    return appExports.tasksSetPriority = function(e, el) {
      var dataId;
      dataId = $(el).parent('[data-id]').attr('data-id');
      return model.at(e.target).set('priority', $(el).attr('data-priority'));
    };
  };

}).call(this);

/*
//@ sourceMappingURL=tasks.map
*/
